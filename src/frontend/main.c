#include "lexer.h"
#include "parser.h"
#include "type_checker.h"
#include "errors.h"
#include "bytecode.h"
#include "codegen.h"
#include "vm.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void print_usage(const char *program_name) {
    printf("Usage: %s <source_file.ocl>\n", program_name);
    printf("  Interprets OCL source code\n");
}

int main(int argc, char *argv[]) {
    if (argc < 2) {
        print_usage(argv[0]);
        return 1;
    }
    
    const char *filename = argv[1];
    
    /* Read source file */
    FILE *file = fopen(filename, "r");
    if (!file) {
        fprintf(stderr, "ERROR: Could not open file '%s'\n", filename);
        return 1;
    }
    
    /* Get file size */
    fseek(file, 0, SEEK_END);
    long file_size = ftell(file);
    fseek(file, 0, SEEK_SET);
    
    /* Read file contents */
    char *source = ocl_malloc(file_size + 1);
    size_t bytes_read = fread(source, 1, file_size, file);
    source[bytes_read] = '\0';
    fclose(file);
    
    if (bytes_read != (size_t)file_size) {
        fprintf(stderr, "ERROR: Failed to read entire file\n");
        ocl_free(source);
        return 1;
    }
    
    /* Create error collector */
    ErrorCollector *errors = error_collector_create();
    
    /* Lexical analysis */
    printf("[INFO] Lexical analysis...\n");
    Lexer *lexer = lexer_create(source, filename);
    size_t token_count = 0;
    Token *tokens = lexer_tokenize_all(lexer, &token_count);
    lexer_free(lexer);
    
    if (error_has_errors(errors)) {
        error_print_all(errors);
        error_collector_free(errors);
        ocl_free(source);
        ocl_free(tokens);
        return 1;
    }
    
    /* Parsing */
    printf("[INFO] Parsing...\n");
    Parser *parser = parser_create(tokens, token_count, filename);
    ProgramNode *program = parser_parse(parser);
    parser_free(parser);
    
    if (error_has_errors(errors)) {
        error_print_all(errors);
        error_collector_free(errors);
        ocl_free(source);
        ocl_free(tokens);
        ast_free((ASTNode *)program);
        return 1;
    }
    
    /* Type checking */
    printf("[INFO] Type checking...\n");
    TypeChecker *type_checker = type_checker_create();
    bool type_check_ok = type_checker_check(type_checker, program);
    type_checker_free(type_checker);
    
    if (!type_check_ok || error_has_errors(errors)) {
        error_print_all(errors);
        error_collector_free(errors);
        ocl_free(source);
        ocl_free(tokens);
        ast_free((ASTNode *)program);
        return 1;
    }
    
    /* Code generation */
    printf("[INFO] Code generation...\n");
    Bytecode *bytecode = bytecode_create();
    CodeGenerator *codegen = codegen_create(errors);
    bool codegen_ok = codegen_generate(codegen, program, bytecode);
    codegen_free(codegen);
    
    if (!codegen_ok || error_has_errors(errors)) {
        error_print_all(errors);
        error_collector_free(errors);
        ocl_free(source);
        ocl_free(tokens);
        ast_free((ASTNode *)program);
        bytecode_free(bytecode);
        return 1;
    }
    
    /* Dump bytecode for debugging */
    printf("[INFO] Generated bytecode:\n");
    bytecode_dump(bytecode);
    printf("\n");
    
    /* Execution */
    printf("[INFO] Executing...\n");
    VM *vm = vm_create(bytecode);
    int exit_code = vm_execute(vm);
    vm_free(vm);
    
    /* Cleanup */
    error_collector_free(errors);
    ocl_free(source);
    /* TODO: Properly free token lexemes */
    /* ocl_free(tokens); */
    ast_free((ASTNode *)program);
    /* TODO: VM owns bytecode, don't double-free */
    /* bytecode_free(bytecode); */
    
    return exit_code;
}
